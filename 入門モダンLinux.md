# 1 Linuxの入門

# 2 Linuxカーネル

システムコール: ユーザプログラムからOSの機能を利用するためのインターフェース

カーネルはモノリシック

主なコンポーネントは

* プロセス管理
* メモリ管理
* ファイルシステム
* ネットワーク
* デバイスドライバ

## プロセス管理

次のような概念がある

* セッション
  * 複数のプロセスグループを含む。ttyを持つ。SIDで識別
* プロセスグループ
  * 複数のプロセスを含む。PGIDで識別
* プロセス
  * プログラムの実行に必要なリソースをグループ化したもの
* スレッド
  * カーネルではプロセスと同じ扱い
* タスク
  * スケジューリング関連の情報PIDなど,nice値などを持つ

## メモリ管理

物理メモリ、仮想メモリともにチャンクに分割されている

プロセスごとにページテーブルがあり、仮想アドレスと物理アドレスの対応を管理する

オーバーコミットにより物理メモリサイズ以上のメモリ確保が可能で、物理メモリ領域の割当は遅延して行われる

仮想アドレスと物理アドレスの対応はTLBにキャッシュされる

Hugepage: ページサイズを大きくすることでTLBのヒット率を上げる

## ネットワーク

* ソケット：通信を抽象化したもの
* TCP/UDP
* IP

カーネルが提供するのは上記のみ

## ファイルシステム

ext4,btrfs,etc...

VFS: ファイルシステムを抽象化して異なるファイルシステムが共存できるように導入されている

## デバイスドライバ

キーボード、マウス、HDDなどのハードウェア、/dev/pts配下の仮想デバイスを制御

`ls -al /sys/devices`でシステム上のデバイスが確認可能

## システムコール

glibcなどがラッパーライブラリ

カーネルモードとユーザ空間の切り替えはコストがかかる

`strace`で確認可能

## カーネルの拡張

### モジュール

必要に応じてカーネルにロードできるプログラム

ハードウェアを自動検出して自動的にロードしてくれることがほとんど

手動でモジュールを読み込みたいときは、ベンダが提供しているモジュールを読み込むなど

ロードしているモジュールは`lsmod`で確認可能

### eBPF

カーネル機能を拡張する手段

セキュリティコントロール、ネットワークロードバランシングなどで利用されている

# 3 シェルとスクリプト

## 用語

### ターミナル

CUIベースのUIを提供するプログラム

### シェル

ターミナル内で動作するコマンドインタプリタとして機能するプログラム

#### ストリーム

入力ストリームと出力ストリームがある

#### 変数

環境変数とシェル変数がある

シェル変数は実行中のシェルのみで有効。例えばシェルが起動する子プロセスには継承されない

#### 終了ステータス

一般的に0は成功、それ以外の1-255は失敗を表す

シェルを閉じたあともバックグラウンドプロセスを動作させたいときは`nohup`,すでに動作しているものに同様のことをしたい場合は`disown`を使う

ターミナルマルチプレクサを使うと、ターミナルを閉じてもバックグラウンドプロセスを動作させることができる

よく使うコマンドは最小限の労力で。aliasを使うとよい

## ターミナルマルチプレクサ

ターミナル内で複数のターミナルを開くことができる

## スクリプト

スクリプトを書くならbashでよい

規模がでかそうならpython,rubyなどを検討する

### 移植性の高いbashスクリプトの書き方

shebangと実行権限を付与する

以下のオプションはつけるべき


```
set -o errexit
set -o nounset
set -o pipefail
```

bashはデフォルトエラーメッセージを出さずに失敗する傾向があるので速やかに失敗すること

インラインドキュメントの整備

80カラム幅にする

linterのデファクトはshellcheck

# 4 アクセス制御

## 4.1 基本

ユーザ: プロセスを起動し、ファイルを所有する。プロセスとはカーネルがメインメモリにロードして実行するプログラム

ファイル: デフォルトではファイルを作成したユーザがファイルのを所有する

プロセス: プロセスなどとの通信、およびデータの永続化のためにファイルを使用する。

## 4.1.2 サンドボックス化

何らかの手段でサンドボックスをホストする環境から隔離する仕組み

## 4.1.3 アクセス制御の仕組み

任意アクセス制御(DAC) : ユーザのIDに基づき、リソースのアクセスを制御する

強制アクセス制: ユーザにはクリアランスレベルが、リソースにはセキュリティラベルが割り当てられている。ユーザのクリアランスレベルと同等、またはそれ以上のセキュリティレベルを持つリソースにのみアクセスできる

Linuxは伝統的にオール・オア・ナッシング。特権ユーザかアクセスが制限された一般ユーザのいずれかであるという考え方

SELinuxは強制アクセス制御を実現する

AppArmorなどもある

## 4.2 ユーザ

システムユーザ: 一般的にはユーザがログインするためのものではなく、サービスの実行に必要なもの

一般ユーザ: ユーザがログインするためのもの

UIDは0-65535の範囲で割り当てられる

どのように管理するかはディストリビューションによる。

## 4.2.2 ユーザの一元管理

ローカルで管理するのではなくサーバで管理

ディレクトリベース: LDAP,Active Directory

ネットワーク経由: Kerberosをしようしてユーザを認証する

## 4.3.1 ファイルのパーミッション

rwx: 読み込み、書き込み、実行

その他

s: setuid,setgid、実行ファイルに対して設定可能。ファイルのオーナーやグループの権限でプログラムを実行する

t: スティッキービット、ディレクトリに対して設定可能。ディレクトリやファイルを所有しているユーザとrootユーザ以外は削除できない

ls -laしたときの先頭の文字の意味

```
[mikamo@kamo3workmini reading_memo]$ ls -la
合計 12
drwxr-xr-x 1 mikamo mikamo   72 10月 16 21:27 .
drwxr-xr-x 1 mikamo mikamo  350 10月 16 21:27 ..
drwxr-xr-x 1 mikamo mikamo  182 10月 29 00:06 .git
-rw-r--r-- 1 mikamo mikamo   28 10月 16 21:27 README.md
-rw-r--r-- 1 mikamo mikamo 4346 11月  3 22:39 入門モダンLinux.md
```

-: 通常ファイル

b: ブロックデバイス

c: キャラクタデバイス

C: コピーオンライトファイルシステムにおけるコピーオンライトを抑制する

d: ディレクトリ

l: シンボリックリンク

p: パイプ

s: ソケット

? : 未知のファイルタイプ

## 4.3.2 プロセスの権限

プロセス実行時のパーミッションに関連する複数のユーザIDがある。

* 実UID(real UID): プロセスを起動したユーザのUID
* 実効UID(effective UID): プロセスが実行されているユーザのUID,メッセージキューなどの共有リソースにアクセスする際に利用
* 保存set-user-ID(saved set-user-ID): setuidビットが設定されている場合に利用。
* ファイルシステムUID: Linux固有。ファイルアクセスのパーミッションを決定するために利用。

forkされるてプロセスが生成されると、親プロセスの実効UIDが引き継がれる

## 4.4 高度な権限管理

### 4.4.1 ケーパビリティ

Linuxカーネルではプロセスを次の2種類のいずれかとして区別してい

* UIDが0の特権プロセス
* それ以外の非特権プロセス

Linux2.2でケーパビリティ関連システムコールが追加され、特権プロセスの権限を細分化することができるようになった

一般的にケーパビリティはシステムレベルのタスクにのみ関連する

ケーパビリティの例

* CAP_CHOWN: chownコマンドを実行できる
* CAP_DAC_OVERRIDE: ファイルのパーミッションを無視してアクセスできる
* CAP_DAC_READ_SEARCH: ファイルのパーミッションを無視して読み込み、検索できる

getcap,setcapコマンドで確認、設定できる


### 4.4.2 seccomp

プロセスが利用できるシステムコールを制限できる

### 4.4.3 ACL

従来のパーミッションに加えて、ユーザやグループごとにアクセス権限を設定できる

## 4.5 アクセス制御の良い実践方法

* 最小権限化
  * 数字を使った設定のほうがシンボルを使うよりも好ましい(厳密さの観点で)
* rootでの実効はできるだけ避けて、sudoを使う

* setuidは避ける,ケーパビリティをw活用する

* 監査する

# 5 ファイルシステム

UNIXではすべてがファイル。

カーネルはプロセスのPIDや実行ファイルなど、動作中のプロセスに関する情報もファイルとして公開している

ファイルシステムがそれらのアクセスを抽象化しているインタフェース

## 5.1 基本

ファイルシステムの殆どが階層化されている

ファイルシステムツリーはディレクトリと通常のファイルという2種類のオブジェクトがある

ファイルシステムにはパーミッションの概念が組み込まれている

一般的にファイルシステムはカーネルに組み込まれている

## 5.2 仮想ファイルシステム

VFS: ファイルシステムを抽象化して異なるファイルシステムが共存できるように導入されている

ファイルやファイルシステムを操作するシステムコールと操作に対応する処理を実装する個々のファイルシステムの間にVFSというレイヤを挟む

異なるファイルシステムを同じインターフェースで操作できるようになる

## 5.2.1 論理ボリュームマネージャ

LVM: 複数の物理ディスクを1つの論理ディスクとして扱うことができる

## 5.2.2 ファイルシステt無の操作

mkfsコマンドでファイルシステムを作成できる

mountコマンドでファイルシステムをマウントできる

fstabファイルでマウントの設定を記述できる

## 5.2.3 一般的なファイルシステムレイアウト

FHS: ファイルシステムの標準化を目的とした仕様

実際にはディストリビューションごとに異なる

## 5.3 疑似ファイルシステム

procfs: プロセス情報をファイルとして公開する

プロセスごとの情報は/proc/PID配下にある

/proc/self/は現在実行中のプロセス

catなどでファイルを読み込むと、プロセスの情報が表示される

低レベルレイヤのでバッグや、システムツールの開発時に便利

sysfs: デバイスドライバの情報をファイルとして公開する

devfs: 物理デバイス、乱数発生など疑似デバイス、入力ファイルを捨てるための書き込み専用デバイスなど

/dev/null,/dev/random,/dev/urandomなどはよく使う

## 5.4 通常ファイル

### 5.4.1 一般的なファイルシステム

ext2,3,4,btrfs,xfsなど

### 5.4.2 インメモリファイルシステム

debugfs,loopfs,pipefs,sockfsなど

### 5.4.3 コピーオンライトファイルシステム

高速なI/Oと少ないディスク容量を両立している

コピー時、メタデータをコピーし、データはコピーしない

コピーデータが変更されると対象のブロックを別領域に保存する

Unionfs,OverlayFS,AUFS,btrfsなど
