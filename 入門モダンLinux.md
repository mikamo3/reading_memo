# 1 Linuxの入門

# 2 Linuxカーネル

システムコール: ユーザプログラムからOSの機能を利用するためのインターフェース

カーネルはモノリシック

主なコンポーネントは

* プロセス管理
* メモリ管理
* ファイルシステム
* ネットワーク
* デバイスドライバ

## プロセス管理

次のような概念がある

* セッション
  * 複数のプロセスグループを含む。ttyを持つ。SIDで識別
* プロセスグループ
  * 複数のプロセスを含む。PGIDで識別
* プロセス
  * プログラムの実行に必要なリソースをグループ化したもの
* スレッド
  * カーネルではプロセスと同じ扱い
* タスク
  * スケジューリング関連の情報PIDなど,nice値などを持つ

## メモリ管理

物理メモリ、仮想メモリともにチャンクに分割されている

プロセスごとにページテーブルがあり、仮想アドレスと物理アドレスの対応を管理する

オーバーコミットにより物理メモリサイズ以上のメモリ確保が可能で、物理メモリ領域の割当は遅延して行われる

仮想アドレスと物理アドレスの対応はTLBにキャッシュされる

Hugepage: ページサイズを大きくすることでTLBのヒット率を上げる

## ネットワーク

* ソケット：通信を抽象化したもの
* TCP/UDP
* IP

カーネルが提供するのは上記のみ

## ファイルシステム

ext4,btrfs,etc...

VFS: ファイルシステムを抽象化して異なるファイルシステムが共存できるように導入されている

## デバイスドライバ

キーボード、マウス、HDDなどのハードウェア、/dev/pts配下の仮想デバイスを制御

`ls -al /sys/devices`でシステム上のデバイスが確認可能

## システムコール

glibcなどがラッパーライブラリ

カーネルモードとユーザ空間の切り替えはコストがかかる

`strace`で確認可能

## カーネルの拡張

### モジュール

必要に応じてカーネルにロードできるプログラム

ハードウェアを自動検出して自動的にロードしてくれることがほとんど

手動でモジュールを読み込みたいときは、ベンダが提供しているモジュールを読み込むなど

ロードしているモジュールは`lsmod`で確認可能

### eBPF

カーネル機能を拡張する手段

セキュリティコントロール、ネットワークロードバランシングなどで利用されている

# 3 シェルとスクリプト

## 用語

### ターミナル

CUIベースのUIを提供するプログラム

### シェル

ターミナル内で動作するコマンドインタプリタとして機能するプログラム

#### ストリーム

入力ストリームと出力ストリームがある

#### 変数

環境変数とシェル変数がある

シェル変数は実行中のシェルのみで有効。例えばシェルが起動する子プロセスには継承されない

#### 終了ステータス

一般的に0は成功、それ以外の1-255は失敗を表す

シェルを閉じたあともバックグラウンドプロセスを動作させたいときは`nohup`,すでに動作しているものに同様のことをしたい場合は`disown`を使う

ターミナルマルチプレクサを使うと、ターミナルを閉じてもバックグラウンドプロセスを動作させることができる

よく使うコマンドは最小限の労力で。aliasを使うとよい

## ターミナルマルチプレクサ

ターミナル内で複数のターミナルを開くことができる

## スクリプト

スクリプトを書くならbashでよい

規模がでかそうならpython,rubyなどを検討する

### 移植性の高いbashスクリプトの書き方

shebangと実行権限を付与する

以下のオプションはつけるべき


```
set -o errexit
set -o nounset
set -o pipefail
```

bashはデフォルトエラーメッセージを出さずに失敗する傾向があるので速やかに失敗すること

インラインドキュメントの整備

80カラム幅にする

linterのデファクトはshellcheck

# 4 アクセス制御

## 4.1 基本

ユーザ: プロセスを起動し、ファイルを所有する。プロセスとはカーネルがメインメモリにロードして実行するプログラム

ファイル: デフォルトではファイルを作成したユーザがファイルのを所有する

プロセス: プロセスなどとの通信、およびデータの永続化のためにファイルを使用する。

## 4.1.2 サンドボックス化

何らかの手段でサンドボックスをホストする環境から隔離する仕組み

## 4.1.3 アクセス制御の仕組み

任意アクセス制御(DAC) : ユーザのIDに基づき、リソースのアクセスを制御する

強制アクセス制: ユーザにはクリアランスレベルが、リソースにはセキュリティラベルが割り当てられている。ユーザのクリアランスレベルと同等、またはそれ以上のセキュリティレベルを持つリソースにのみアクセスできる

Linuxは伝統的にオール・オア・ナッシング。特権ユーザかアクセスが制限された一般ユーザのいずれかであるという考え方

SELinuxは強制アクセス制御を実現する

AppArmorなどもある

## 4.2 ユーザ

システムユーザ: 一般的にはユーザがログインするためのものではなく、サービスの実行に必要なもの

一般ユーザ: ユーザがログインするためのもの

UIDは0-65535の範囲で割り当てられる

どのように管理するかはディストリビューションによる。

## 4.2.2 ユーザの一元管理

ローカルで管理するのではなくサーバで管理

ディレクトリベース: LDAP,Active Directory

ネットワーク経由: Kerberosをしようしてユーザを認証する

## 4.3.1 ファイルのパーミッション

rwx: 読み込み、書き込み、実行

その他

s: setuid,setgid、実行ファイルに対して設定可能。ファイルのオーナーやグループの権限でプログラムを実行する

t: スティッキービット、ディレクトリに対して設定可能。ディレクトリやファイルを所有しているユーザとrootユーザ以外は削除できない

ls -laしたときの先頭の文字の意味

```
[mikamo@kamo3workmini reading_memo]$ ls -la
合計 12
drwxr-xr-x 1 mikamo mikamo   72 10月 16 21:27 .
drwxr-xr-x 1 mikamo mikamo  350 10月 16 21:27 ..
drwxr-xr-x 1 mikamo mikamo  182 10月 29 00:06 .git
-rw-r--r-- 1 mikamo mikamo   28 10月 16 21:27 README.md
-rw-r--r-- 1 mikamo mikamo 4346 11月  3 22:39 入門モダンLinux.md
```

-: 通常ファイル

b: ブロックデバイス

c: キャラクタデバイス

C: コピーオンライトファイルシステムにおけるコピーオンライトを抑制する

d: ディレクトリ

l: シンボリックリンク

p: パイプ

s: ソケット

? : 未知のファイルタイプ

## 4.3.2 プロセスの権限

プロセス実行時のパーミッションに関連する複数のユーザIDがある。

* 実UID(real UID): プロセスを起動したユーザのUID
* 実効UID(effective UID): プロセスが実行されているユーザのUID,メッセージキューなどの共有リソースにアクセスする際に利用
* 保存set-user-ID(saved set-user-ID): setuidビットが設定されている場合に利用。
* ファイルシステムUID: Linux固有。ファイルアクセスのパーミッションを決定するために利用。

forkされるてプロセスが生成されると、親プロセスの実効UIDが引き継がれる

## 4.4 高度な権限管理

### 4.4.1 ケーパビリティ

Linuxカーネルではプロセスを次の2種類のいずれかとして区別してい

* UIDが0の特権プロセス
* それ以外の非特権プロセス

Linux2.2でケーパビリティ関連システムコールが追加され、特権プロセスの権限を細分化することができるようになった

一般的にケーパビリティはシステムレベルのタスクにのみ関連する

ケーパビリティの例

* CAP_CHOWN: chownコマンドを実行できる
* CAP_DAC_OVERRIDE: ファイルのパーミッションを無視してアクセスできる
* CAP_DAC_READ_SEARCH: ファイルのパーミッションを無視して読み込み、検索できる

getcap,setcapコマンドで確認、設定できる


### 4.4.2 seccomp

プロセスが利用できるシステムコールを制限できる

### 4.4.3 ACL

従来のパーミッションに加えて、ユーザやグループごとにアクセス権限を設定できる

## 4.5 アクセス制御の良い実践方法

* 最小権限化
  * 数字を使った設定のほうがシンボルを使うよりも好ましい(厳密さの観点で)
* rootでの実効はできるだけ避けて、sudoを使う

* setuidは避ける,ケーパビリティをw活用する

* 監査する

# 5 ファイルシステム

UNIXではすべてがファイル。

カーネルはプロセスのPIDや実行ファイルなど、動作中のプロセスに関する情報もファイルとして公開している

ファイルシステムがそれらのアクセスを抽象化しているインタフェース

## 5.1 基本

ファイルシステムの殆どが階層化されている

ファイルシステムツリーはディレクトリと通常のファイルという2種類のオブジェクトがある

ファイルシステムにはパーミッションの概念が組み込まれている

一般的にファイルシステムはカーネルに組み込まれている

## 5.2 仮想ファイルシステム

VFS: ファイルシステムを抽象化して異なるファイルシステムが共存できるように導入されている

ファイルやファイルシステムを操作するシステムコールと操作に対応する処理を実装する個々のファイルシステムの間にVFSというレイヤを挟む

異なるファイルシステムを同じインターフェースで操作できるようになる

## 5.2.1 論理ボリュームマネージャ

LVM: 複数の物理ディスクを1つの論理ディスクとして扱うことができる

## 5.2.2 ファイルシステt無の操作

mkfsコマンドでファイルシステムを作成できる

mountコマンドでファイルシステムをマウントできる

fstabファイルでマウントの設定を記述できる

## 5.2.3 一般的なファイルシステムレイアウト

FHS: ファイルシステムの標準化を目的とした仕様

実際にはディストリビューションごとに異なる

## 5.3 疑似ファイルシステム

procfs: プロセス情報をファイルとして公開する

プロセスごとの情報は/proc/PID配下にある

/proc/self/は現在実行中のプロセス

catなどでファイルを読み込むと、プロセスの情報が表示される

低レベルレイヤのでバッグや、システムツールの開発時に便利

sysfs: デバイスドライバの情報をファイルとして公開する

devfs: 物理デバイス、乱数発生など疑似デバイス、入力ファイルを捨てるための書き込み専用デバイスなど

/dev/null,/dev/random,/dev/urandomなどはよく使う

## 5.4 通常ファイル

### 5.4.1 一般的なファイルシステム

ext2,3,4,btrfs,xfsなど

### 5.4.2 インメモリファイルシステム

debugfs,loopfs,pipefs,sockfsなど

### 5.4.3 コピーオンライトファイルシステム

高速なI/Oと少ないディスク容量を両立している

コピー時、メタデータをコピーし、データはコピーしない

コピーデータが変更されると対象のブロックを別領域に保存する

Unionfs,OverlayFS,AUFS,btrfsなど

# 6 アプリケーション、パッケージ管理、コンテナ

## 6.1 基本

プログラム: バイナリ化スクリプト

プロセス: メインメモリにロードされ、スリープしていない状態の実行中のプログラム

デーモン: =サービス,特定の機能を提供するバックグラウンドプロセス

アプリケーション: 通常はUIを始めとした実施素敵なプログラム

サプライチェーン: ソフトウェア開発者や販売者の集まり、パッケージ単位でアプリを探して利用できるようにする

ブート: ハードウェアとOSを初期化し、Linuxを利用できる状態にすること

## 6.2  Linuxの起動プロセス

UEFI,BIOSがハードウェアを初期化してブートローダーに処理を引き継ぐ

ブートローダーがカーネルをロードする。カーネルは基本的に/boot配下にある

圧縮されているので展開してメインメモリにロードする

カーネルは制御をinitプロセスに引き継ぐ

initはシステム全体でデーモンを起動する。PIDは1

環境に応じて他のユーザ空間レベルの初期化が行われる

initシステムはさいきんではsystemdが主流

## 6.3 systemd

alt initシステム

移植性の高さと統一されたインタフェースが特徴

### 6.3.1 ユニット

機能やリソオースによって異なる意味を持つ論理的なグループ

service: サービスやアプリケーションの管理について
target: 依存関係
mount: mountpointについて
timer: cronjob

ユニットファイルは、パッケージインストールされたもの、システム管理者が設定したもの、一時的な実行時のユニットなどがある

### 6.3.2 systemctlによる管理

systemdを介してサービスを管理するコマンド

### 6.3.3 journalctlによる監視

systemdが記録するログを一元的に保存する

## 6.4 サプライチェーン

ソフトウェアメンテナ、リポジトリ、ターゲットシステムで構成される

パッケージマネージャは従来型(yum pacman)、コンテナベース、モダンなパッケージマネージャ(flatpak,snappy)がある

## 6.5 パッケージとパッケージマネージャ

パッケージは主に圧縮されたファイルでメタデータなども含む場合がる

パッケージマネージャでパッケージを管理する

## 6.6 コンテナ 

カーネルが提供するnamespaceとcgroupを利用してプロセスを隔離する

dockerがメジャー. OCI(Open Container Initiative)が標準化を進めている

OCIではランタイム仕様、イメージ仕様、配布仕様の3つの仕様を策定している

### 6.6.1 namespace

プロセスごとにリソースの見え方を変えることができる

### 6.6.2 cgroup

リソースの使用を制限する. v1,v2があり、いずれv2に移行する

v1はcgroupやそれに対応するコントローラを追加するという形で機能を拡張している

v2はcgroupの階層構造を廃止し、コントローラを統合している

### 6.6.3 コピーオンライトファイルシステム

異なる依存関係のコンテンツを効率的に階層化できる

### 6.6.5 他のコンテナ管理ツール

podman,buildah

buildahでOCIイメージを作成し、podmanで実行する

podmanはコンテナ生成時にデーモンが不要でセキュリティ面で優れる

## 6.7 モダンなパッケージマネージャ

主にコンテナを使用してクロスディストリビューションのパッケージ管理を行う

snap,flatpak,appimage,homebrewなど

# 7 ネットワーク

## 7.1 基本

RFCをよむのがいい

## 7.2 TCP/IPスタック

IETF使用で定義されている

層構造になっていて各層は自身と上下の層だけを認識する

* リンク層 物理デバイス間でのパケット送信を行う
* インターネット層 ルーテイングを担当する。IPアドレスを扱う
* トランスポート層 TCP/UDPなどのエンドツーエンドの通信を制御する
* アプリケーション層 HTTP,SSHなどのプロトコルを扱う

### 7.2.1 リンク層

ハードウェアまたはそれに近いものを対象としている

インターフェースは物理的なものであったりループバックのような仮想インタフェースであったりする

### 7.2.1.1 NIC

ifconfig,ip -aなどで確認可能

最近ではインタフェースの命名がwlp1s0などになっている

p1: PCIバスの1番目のスロットに接続されている

s0: スロット0

### 7.2.1.2 ARP

MACアドレスとIPアドレスの対応を管理する

arpコマンドで確認可能,もしくは ip neigh

## 7.2.2 インターネット層

インターネット層の設計はネットワークインフラの信頼性は低く、ノードは頻繁に変更されるという前提

インターネット層はベストエフォートでパケットは独立している。パケットの順序、再送、配送保証は上位のトランスポート層で対応

### 7.2.2.1 IPv4

IPヘッダで重要なもの

* 送信元アドレス
* 宛先アドレス
* プロトコル
* TTL
* サービスタイプToS(QoS)

特別な意味を持つIPアドレス

* 127.0.0.1: ループバックアドレス
* 169.254.0.0./16 リンクローカルアドレス。そこに送られたパケットはネットワークの外に転送されない。
* 224.0.0.0/24 マルチキャストアドレス。同じネットワーク上の複数のホストにパケットを送信する
* 0.0.0.0 ルーティング歴内アドレス。存在するすべてのIPv4アドレスを参照する。リッスンする際に指定して、利用可能なすべてのIPをリッスンするという意味になる

### 7.2.2.2 IPv6

アドレスは128ビット

連続した0は::で省略できる

### 7.2.2.3 ICMP

Internet Control Message Protocol

ICMPはエラーメッセージや可用性などの運用情報を送信するために利用される

### 7.2.2.4 ルーティング

システムに届いた個々のパケットをどのように送るかを決める

route -nで確認可能

FlagのUGがあるものがデフォルトゲートウェイ

BGP Border Gateway Protocol

BGPではAS(Autonomous System)と呼ばれる単位でルーティングを行う、これらのASがルーティングと到達経路を共有してインターネット上でパケットを配送するルートを提供する

## 7.2.3 トランスポート層

### 7.2.3.1 ポート

welknown portへのバインドはroot権限が必要

1024-49151までが登録済みポート。IANAによて管理されている

49152-65535までが動的ポート(エフェメラルポート)、アプリがwebサーバに接続する場合や、プライベートなサービスに利用される

ポートとプロトコルの対応は/etc/servicesに記述されている

ローカルマシンで利用されているポートはnmapで確認できる

### 7.2.3.2 TCP

コネクション志向のプロトコル

セッションベースであるためパケットの順女性を保証し、エラーが発生した場合は再送する

ペイロードは平文、暗号化するにはTLSを使う

### 7.2.3.3 UDP

コネクションレスのプロトコル.データグラムチェックサムをサポートしており整合性を確保できる。

シンプルでオーバヘッドが少なく、高いスループットを確保できる

## 7.2.4 ソケット

通信のエンドポイントでTCP,UDPとIPアドレスを設定する。

ssコマンドでサマリなどを確認可能

## 7.3 DNS

IPのアドレスとホスト名の対応を管理する

/etc/hostsに記載

DNSにて分散的にホスト名を管理する

ドメイン名空間

.をルートとして階層構造になっている

FQDN = ホスト名.ドメイン名 eg: dome.mhausenblas.info. infoはトップレベルドメイン 右端の.はルートドメイン。普通は省略される

リソースレコード: ドメイン名空間のノードまたはリーフにあるペイロード

ネームサーバ: ドメインツリーの構造に関する情報を保持するサーバ。空間に関する完全な情報を持っているネームサーバを権威サーバと呼ぶ

リゾルバ: ネームサーバから情報を取得するプログラム

トップレベルドメイン

IANAが管理している

gTLD: .com,.net,.org,.info,.biz,.name,.pro,.museum,.coop,.aero,.int,.edu,.gov,.mil

ccTLD: 国別

sTLD: スポンサードトップレベルドメイン gov,eduなど使用する資格を制限するルールに基づき運用

### 7.3.1 DNSレコード

A: IPv4アドレス
AAAA: IPv6アドレス
CNAME: 別名
NS: DNSゾーンが権威ネームサーバを使うように指定するネームサーバレコード
PTR: 逆引きレコード,Aレコードの逆引き
SRV: サービスロケータレコード、ハードコードではなく一般的な発見メカニズムでプロトコルとポートなどを提供する
TXT: テキストレコード、任意のテキスト情報を提供する。今日ではDNS拡張で使われる

### 7.3.2 DNSルックアップ

host,dig,drillコマンドで確認可能

今後登場する新しいレコードタイプをRFCで定義するのではなく、SRVレコードを使用してサービスのIPアドレスとポートを通知するう

## 7.4 アプリケーション層ネットワーク

### 7.4.1 ウェブ

URL,HTTP,HTMLの3つの技術が組み合わさっている

### 7.4.2 SSH

### 7.4.3 ファイル転送

rsyncはSSHを使ってファイルを転送する。高速

### 7.4.4 NFS

## 7.5 ネットワークの高度なトピック

### 7.5.1 whois

ドメイン名やIPアドレスのオーナーなどを調べることができる

### 7.5.2 DHCP

ホストへのIP自動割当を行う。

### 7.5.3 wiresharkとtshark

低レベルのネットワークトラフィック解析、tsharkはコマンドラインで利用できる

tcpdumpも同様に利用される

# 8 オブザーバビリティ

Linuxとそのアプリケーションが生成するシグナルを収集し、利用することで判断を行う。

* プロセスのメモリ消費の把握
* ディスク領域がどのくらいで不足するかの予測
* カスタムイベントのアラートを取得

オブザーバビリティは大抵は事後になる

## 8.1 基本

### 8.1.1 戦略

OODAループ: Observe, Orient, Decide, Act

シグナルから実効性のある洞察を得る

### 8.1.2 用語

* オブザーバビリティ
  * 外部から情報を測定してシステムの内部状態を評価して、何らかの行動を取ることが目的、
* シグナルの種類
  * システムの状態に関する情報を発信するさまざまな手段のこと
* ソース
  * シグナルを生成するもの
* 宛先
  * シグナルを処理する場所、ユーザインタフェースを公開する宛先をフロントエンドと呼ぶ
* テレメトリ
  * ソースからシグナルを抜き取り、宛先に転送雨するプロセスのこと、多くの場合、シグナルを収集、前処理するエージェントを採用する

### 8.1.3シグナルの種類

#### 8.1.3.1 ログ

人間が扱うことを前提,テキストベース,タイムスタンプがつく、理想的にはメッセージの各部分に対して明確な意図があり、構造化されている

構造化ログはほぼJSON.

基本的には自動処理するのは難しいが人間には読みやすくなっている

#### 8.1.3.2 メトリクス

定期的にサンプリングされた数値データで時系列

個々のデータは大きさ、または識別用でメタデータが追加される

生のメトリクスを扱うことはないが集計やグラフで使用したり、アラートを生成する

以下のような区別がある

カウンタ、ゲージ、ヒストグラム

#### 8.1.3.3 トレース

実行時の情報を動的に収集する。デバッグは性能評価で利用

